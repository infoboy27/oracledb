
<!DOCTYPE html>
                                    
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.8 from src/site/markdown/doc-files/getting-started.md at 2025-07-13

 | Rendered using Apache Maven Default Skin
-->
  <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.8" />
          <title>Oracle REST Data Services Java API Reference &#x2013; Introduction</title>
    <link rel="stylesheet" href="../css/maven-base.css" />
  <link rel="stylesheet" href="../css/maven-theme.css" />
  <link rel="stylesheet" href="../css/site.css" />
  <link rel="stylesheet" href="../css/print.css" media="print" />
          </head>
<body class="composite">
                                                  <div id="bodyColumn">
  <div id="contentBox">
    <h1>Introduction</h1>
<p>This document describes how to develop and deploy plugins that integrate with the Oracle REST Data Services (ORDS) runtime.</p>
<div class="section">
<h2><a name="Further_Information"></a>Further Information</h2>
<p>For a more a more detailed reference, consult the <a href="./developer-guide.html">developer guide</a>.</p></div>
<div class="section">
<h2><a name="Examples"></a>Examples</h2>
<p>Below are some examples that give a flavour of the programming model.</p>
<div class="section">
<h3><a name="Hello_World"></a>Hello World</h3>
<p>The Hello World example below demonstrates the basics of creating a request handler plugin:</p>

<div>
<div>
<pre class="source">@Dispatches(@PathTemplate(&quot;/hello&quot;))
@Provides                            
public class HelloWorld extends HttpServlet {
 public doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
 	response.setContentType(&quot;text/plain&quot;);
 	response.getWriter().println(&quot;Hello World&quot;);
 }
}
</pre></div></div>

<ul>

<li>Create a class that sub-classes <a class="externalLink" href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html">HttpServlet</a>.</li>
<li>Advertise the class to the Dependency Injection framework via the <a href="../oracle/dbtools/plugin/api/di/annotations/Provides.html">@Provides</a> annotation</li>
<li>Advertise the class to the request dispatching framework via the <a href="../oracle/dbtools/plugin/api/http/annotations/Dispatches.html">@Dispatches</a> annotation</li>
<li>Advertise the request path that the class responds to via the <a href="../oracle/dbtools/plugin/api/http/annotations/PathTemplate.html">@PathTemplate</a> annotation</li>
<li>Override the HttpServlet <a class="externalLink" href="https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html#doGet-javax.servlet.http.HttpServletRequest-javax.servlet.http.HttpServletResponse-">doGet</a> () method to provide the logic of the handler.</li>
</ul></div>
<div class="section">
<h3><a name="Injecting_Dependencies"></a>Injecting Dependencies</h3>
<p>A plugin can express it&#x2019;s dependencies on external APIs using the <a class="externalLink" href="https://jakarta.ee/specifications/dependency-injection/2.0/apidocs/jakarta/inject/inject">@Inject</a> annotation on its constructor.</p>

<div>
<div>
<pre class="source">@Dispatches(@PathTemplate(&quot;/uses-logging&quot;))
@Provides                            
public class UsesLogging extends HttpServlet {

 @Inject
 public UsesLogging(Logger log) {
 	this.log = log;
 }   
 public doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
    log.fine(&quot;received request:\n&quot; + request.toString());
 	response.setContentType(&quot;text/plain&quot;);
 	response.getWriter().println(&quot;Hello World&quot;);
 	log.fine(&quot;processed request&quot;);
 }

 private final Logger log;
}
</pre></div></div>

<ul>

<li>Before instantiating the <tt>UsesLogging</tt> type, the DI framework looks for a constructor annotated with <a class="externalLink" href="https://jakarta.ee/specifications/dependency-injection/2.0/apidocs/jakarta/inject/inject">@Inject</a>. It then examines the arguments of the constructor and attempts to resolve an implementation of the specified type. Once all dependencies have been resolved, the DI framework invokes the Constructor with the required arguments.</li>
<li>In this case, the servlet uses the <a href="../oracle/dbtools/plugin/api/di/AvailableDependencies.html#LOG">Logger</a> service to log some debugging information.</li>
<li>The set of services that can be injected is documented in the <a href="../oracle/dbtools/plugin/api/di/AvailableDependencies.html">AvailableDependencies</a> enum.</li>
</ul>
<h1>Tutorial</h1></div></div>
<div class="section">
<h2><a name="About_the_Tutorial_Files"></a>About the Tutorial Files</h2>
<p>All of the files referenced in this tutorial are included in the product distribution under the <tt>examples/plugins</tt> folder:</p>

<div>
<div>
<pre class="source">${ORDS_HOME}
|-- examples
     |-- plugins
          |-- lib
          |-- plugin-demo
              |-- src
</pre></div></div>

<p>where <tt>${ORDS_HOME}</tt> is the location where the product distribution was unzipped.</p></div>
<div class="section">
<h2><a name="Prepare_Environment"></a>Prepare Environment</h2>
<p>Consult the instructions in the <a class="externalLink" href="http://docs.oracle.com/cd/E56351_01/index.htm">Oracle REST Services Documentation</a> to install and configure ORDS.</p>
<div class="section">
<h3><a name="Enable_database_schema"></a><a name="enable-schema"></a> Enable database schema</h3>
<p>To make a database schema accessible to ORDS, it must be explicitly enabled. To demonstrate this we will create a new schema and enable it:</p>

<div>
<div>
<pre class="source">$ sqlplus /nolog
SQL&gt; CONNECT SYS as SYSDBA
Enter password: 
SQL&gt; create user TEST_SCHEMA identified by TEST_SCHEMA_password;
SQL&gt; grant connect, resource to TEST_SCHEMA;
SQL&gt; DISCONNECT
SQL&gt; CONNECT TEST_SCHEMA
Enter password:
SQL&gt; execute ords.enable_schema;
SQL&gt; commit;
</pre></div></div>

<p><i>Note:</i> Replace <tt>TEST_SCHEMA_password</tt> with your own choice of password.</p>
<div class="section">
<h4><a name="Verify_schema_is_enabled"></a>Verify schema is enabled</h4>
<p>To verify if a schema is enabled for ORDS access, check the <tt>USER_ORDS_SCHEMAS</tt> view:</p>

<div>
<div>
<pre class="source">SQL&gt; select * from USER_ORDS_SCHEMAS;

ID PARSING_SCHEMA TYPE      PATTERN
-- -------------- --------- -----------
 2 TEST_SCHEMA    BASE_PATH test_schema
</pre></div></div>
</div></div></div>
<div class="section">
<h2><a name="Creating_a_Plugin"></a>Creating a Plugin</h2>
<p>In this guide we will walk through building and deploying the <tt>plugin-demo</tt> plugin that queries the database to determine the current database user and echo that information in the response. This example uses <a class="externalLink" href="http://ant.apache.org">Apache ANT</a> to manage the build process.</p>
<div class="section">
<h3><a name="Prerequisities"></a>Prerequisities</h3>
<ul>

<li>JDK 1.8 or later.</li>
<li>Apache Ant 1.8.2 or later.</li>
<li>Installed and configured ORDS as detailed above.</li>
</ul></div>
<div class="section">
<h3><a name="About_the_Plugin_project_folder_structure"></a>About the Plugin project folder structure</h3>
<p>The <tt>plugin-demo</tt> source files are located within the <tt>${ORDS_HOME}</tt> folder at:</p>

<div>
<div>
<pre class="source">${ORDS_HOME}/examples/plugins/plugin-demo
</pre></div></div>

<p>The folder contains the following:</p>
<ul>

<li><tt>src</tt> folder which contains:
<ul>

<li><tt>PluginDemo.java</tt> - the Java source code of the plugin.</li>
</ul>
</li>
<li><tt>build.xml</tt> - ANT build script, which compiles and packages the source code</li>
<li><tt>built</tt> - folder generated by <tt>build.xml</tt> which will contain the packaged plugin: <tt>plugin-demo.jar</tt>.</li>
</ul>
<p>Located in the parent folder is a <tt>lib/</tt> folder which holds the <tt>.jar</tt> files required to compile plugins.</p>
<div class="section">
<h4><a name="Required_Libraries"></a>Required Libraries</h4>
<p>To compile a plugin the following libraries must be in the classpath:</p>
<ul>

<li><a href="#pajar">plugin-api.jar</a></li>
<li><a href="#paptjar">plugin-apt.jar</a></li>
<li><a href="#jijar">javax.inject.jar</a></li>
<li><a href="#sajar">servlet-api-3.1.0.jar</a></li>
<li><a href="#ojdbc">ojdbc11.jar</a></li>
</ul>
<div class="section">
<h5><a name="Required_Library_Locations"></a>Required Library Locations</h5>
<p>Each of the required jars is included in the product distribution in the <tt>${ORDS_HOME}/examples/plugins/lib</tt> folder.</p></div>
<div class="section">
<h5><a name="About_plugin-api.jar"></a><a name="pajar"></a>About plugin-api.jar</h5>
<p>This library provides the glue code - such as <a href="../oracle/dbtools/plugin/api/http/annotations/Dispatches.html">@Dispatches</a> - to weave the plugin into the runtime.</p></div>
<div class="section">
<h5><a name="About_plugin-apt.jar"></a><a name="paptjar"></a>About plugin-apt.jar</h5>
<p>This library provides the annotation processor that makes classes annotated with <a href="../oracle/dbtools/plugin/api/di/annotations/Provides.html">@Provides</a> discoverable.</p></div>
<div class="section">
<h5><a name="About_javax.inject.jar"></a><a name="jijar"></a>About javax.inject.jar</h5>
<p>This library provides the <a class="externalLink" href="http://docs.oracle.com/javaee/7/api/javax/inject/package-summary.html">JSR-330 API</a> types such as <a class="externalLink" href="https://jakarta.ee/specifications/dependency-injection/2.0/apidocs/jakarta/inject/inject">@Inject</a>.</p></div>
<div class="section">
<h5><a name="About_servlet-api-3.1.0.jar"></a><a name="sajar"></a>About servlet-api-3.1.0.jar</h5>
<p>This library provides the <a class="externalLink" href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/package-summary.html">Java Servlet 3.1.0 API</a> types, such as <a class="externalLink" href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServlet.html">HttpServlet</a>.</p></div>
<div class="section">
<h5><a name="About_ojdbc11.jar"></a><a name="ojdbc"></a>About ojdbc11.jar</h5>
<p>This library is optional and is only required if the plugin needs to access the Oracle JDBC Extension APIs such as <a class="externalLink" href="https://docs.oracle.com/en/database/oracle/oracle-database/23/jajdb/oracle/jdbc/OracleConnection.html">OracleConnection</a>.</p></div></div></div>
<div class="section">
<h3><a name="About_PluginDemo.java"></a>About PluginDemo.java</h3>
<p>The source code of the plugin is reproduced below, following that is a point by point explanation of the source code.</p>

<div>
<div>
<pre class="source">package example;

import java.io.IOException;
import java.sql.*;
import jakarta.inject.Inject;
import javax.servlet.ServletException;
import javax.servlet.http.*;
import oracle.dbtools.plugin.api.di.annotations.Provides;
import oracle.dbtools.plugin.api.http.annotations.*;
import oracle.dbtools.plugin.api.routes.*;

/**
 * This example plugin {@link HttpServlet} demonstrates:
 * &lt;ul&gt;
 * &lt;li&gt;Using the injected {@link Connection} to query the database.&lt;/li&gt;
 * &lt;li&gt;Using the injected {@link PathTemplates} service to decode the parameters
 * of the servlet's {@link PathTemplateMatch}.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;h4&gt;Testing the Servlet&lt;/h4&gt; Invoke the servlet with the following URL:
 *
 * &lt;pre&gt;
 *  http://&lt;i&gt;server&lt;/i&gt;/ords/&lt;i&gt;schema&lt;/i&gt;/demos/plugin?who=&lt;i&gt;somebody&lt;/i&gt;
 * &lt;/pre&gt;
 *
 * where:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;i&gt;server&lt;/i&gt; is the hostname and port of the server.&lt;/li&gt;
 * &lt;li&gt;&lt;i&gt;schema&lt;/i&gt; is the name of the REST enabled database schema.&lt;/li&gt;
 * &lt;li&gt;&lt;i&gt;somebody&lt;/i&gt; is any value you wish, e.g. a person's name.&lt;/li&gt;
 * &lt;ul&gt;
 * For example:
 *
 * &lt;pre&gt;
 *  http://localhost:8080/ords/test_schema/demos/plugin?who=Scott
 * &lt;/pre&gt;
 *
 * @author cdivilly
 *
 */
@Provides
@Dispatches(@PathTemplate(&quot;/demos/plugin&quot;))
class PluginDemo extends HttpServlet {
  @Inject
  PluginDemo(Connection conn, PathTemplates pathTemplates) {
    this.conn = conn;
    this.pathTemplates = pathTemplates;
  }

  public void doGet(HttpServletRequest request,
                    HttpServletResponse response)
      throws ServletException, IOException {

    PathTemplateMatch match = pathTemplates
                                .matchedTemplate(request);
    try {
      /* retrieve 'who' query parameter */
      String who = match.parameters().get(&quot;who&quot;);
      who = null == who ? &quot;anonymous&quot; : who;

      /* execute database query */
      PreparedStatement ps = conn
       .prepareStatement(&quot;select sys_context('USERENV','CURRENT_USER') from dual&quot;);

      ResultSet rs = ps.executeQuery();
      rs.next();

      /* determine the database user */
      String user = rs.getString(1);

      /* Print the greeting */
      response.getWriter().println(user + &quot; says hello to: &quot; + who);
      rs.close();
      ps.close();
    } catch (SQLException e) {
      throw new ServletException(e);
    }
  }

  private final Connection    conn;
  private final PathTemplates pathTemplates;
}
</pre></div></div>

<ul>

<li>The <tt>PluginDemo</tt> type is annotated with <tt>@Provides</tt> to indicate that it offers a service, in this case it offers the <tt>HttpServlet</tt> service.</li>
<li>The type is also annotated with the <tt>@Dispatches</tt> and <tt>@PathTemplate</tt> annotations which indicate the request URL pattern that the servlet listens for.</li>
<li>The <tt>PluginDemo</tt> constructor is annotated with <tt>@Inject</tt> to indicate that this constructor should be used by the dependency injection framework to instantiate instances of the type.</li>
<li>The arguments of the constructor indicate the types that <tt>PluginDemo</tt> depends on:
<ul>

<li>The first argument indicates that a database <tt>Connection</tt> is required, ORDS connects this connection instance to a database schema, which schema is determined by the request URL to database schema mapping rules.</li>
<li>The second argument is the <tt>PathTemplates</tt> service which provides a method for determining the <tt>PathTemplate</tt> bound to a request.</li>
</ul>
</li>
<li><tt>PluginDemo</tt> overrides the <tt>doGet()</tt> method to indicate that it supports the <tt>GET</tt> HTTP method.</li>
<li>It uses the <tt>PathTemplates</tt> service to determine the <tt>PathTemplateMatch</tt> bound to the request.</li>
<li>It decodes the <tt>PathTemplate</tt> parameters, and extracts the value of the <tt>who</tt> parameter.</li>
<li>The <tt>Connection</tt> instance is queried to determine the identity of the current database user.</li>
<li>Finally the message showing the database user and the value of the <tt>who</tt> parameter is printed in the response.</li>
</ul></div>
<div class="section">
<h3><a name="Build_the_Plugin"></a>Build the Plugin</h3>
<p>In the <tt>plugin-demo</tt> folder type the following command:</p>

<div>
<div>
<pre class="source">$ ant
</pre></div></div>

<p>The source code will be compiled and packaged into an archive named <tt>built/plugin-demo.jar</tt></p></div>
<div class="section">
<h3><a name="Package_the_Plugin"></a>Package the Plugin</h3>
<p>Copy plugin-demo.jar to extension library:</p>

<div>
<div>
<pre class="source">$  cp built/plugin-demo.jar ${ORDS_HOME}/lib/ext/
</pre></div></div>

<h1>Test the Plugin</h1>
<p>Start ords in standalone mode.</p>

<div>
<div>
<pre class="source">$ cd ${ORDS_HOME}/bin
$ ords --config config_dir serve
</pre></div></div>
</div></div>
<div class="section">
<h2><a name="About_Request_URLs"></a>About Request URLs</h2>
<p>The plugin we have built needs a database connection to function. Therefore ORDS must be able to figure out what database and schema to connect to. ORDS does this by examine the Request URL and mapping the URL to the appropriate database pool and database schema.</p>
<p>If ORDS cannot determine a mapping, then it will report a <tt>404 Not Found</tt> status for the request URL.</p>
<div class="section">
<h3><a name="Configuring_a_database_schema_mapping"></a>Configuring a database schema mapping</h3>
<p>To map a database schema to a URL, you must enable the schema to be accessed by ORDS, as we did in the section titled <a href="#enable-schema">&#x2018;Enable Database Schema&#x2019;</a>.</p></div></div>
<div class="section">
<h2><a name="Try_the_Request_URL"></a>Try the Request URL</h2>
<p>With ORDS running in standalone mode on <tt>localhost</tt>, try the following URL:</p>

<div>
<div>
<pre class="source">http://localhost:8080/ords/test_schema/demos/plugin?who=Scott
</pre></div></div>

<p>The browser should display the following text:</p>

<div>
<div>
<pre class="source">TEST_SCHEMA says hello to: Scott
</pre></div></div>

<ul>

<li>The <tt>/test_schema</tt> portion of the request URL maps the request to the <tt>TEST_SCHEMA</tt> database schema.</li>
<li>A <tt>Connection</tt> instance connected to the <tt>TEST_SCHEMA</tt> schema is injected into the <tt>PluginDemo</tt> instance.</li>
<li><tt>PluginDemo</tt> queries the <tt>Connection</tt> to determine the current user and decodes the <tt>{who}</tt> parameter bound to the request URL, and uses this information to construct the message displayed above.</li>
</ul></div>
  </div>
</div>
<div class="clear">
  <hr/>
</div>
                          </body>
</html>